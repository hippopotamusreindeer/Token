// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;
pragma abicoder v2;

import "./Jerry.sol"; // Import your Jerry token contract
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";

contract FeeCollector {
    address private constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address payable public developerWallet;
    Jerry public jerryToken;
    IUniswapV2Router02 public uniswapRouter;

    uint256 public constant minAmountToSwap = 10000000 * 10**18; // Assuming 18 decimals for the Jerry token
    address private WETH;

    // Events
    event Funded(address indexed funder, uint256 amount);
    event SwapTriggered(uint256 balance);
    event SwapApproved(uint256 amount);
    event SwapExecuted(uint256 amountOut);
    event EtherTransferred(uint256 amount);
    event SwapFailed(string reason);  // New Event
    event EtherTransferFailed(string reason);  // New Event

    constructor(address _jerryToken, address _developerWallet) {
        jerryToken = Jerry(_jerryToken);
        developerWallet = payable(_developerWallet);
        uniswapRouter = IUniswapV2Router02(UNISWAP_V2_ROUTER);
        WETH = uniswapRouter.WETH();
    }

    function setDeveloperWallet(address payable _developerWallet) external {
        require(_developerWallet != address(0), "Invalid address");
        developerWallet = _developerWallet;
    }

    receive() external payable {
        require(msg.sender == developerWallet, "Only the developer can send ETH");
        emit Funded(msg.sender, msg.value);
    }

    function fundContract() external payable {
        require(msg.sender == developerWallet, "Only the developer wallet can fund the contract");
        emit Funded(msg.sender, msg.value);
    }

    function getCollectedJerryAmount() external view returns (uint256) {
        return jerryToken.balanceOf(address(this));
    }

    function getContractEtherBalance() external view returns (uint256) {
        return address(this).balance;
    }

function triggerSwap() external {
        uint256 balance = jerryToken.balanceOf(address(this));
        emit SwapTriggered(balance);

        if (balance >= minAmountToSwap) {
            bool approveSuccess = jerryToken.approve(address(uniswapRouter), balance);
            require(approveSuccess, "Approval failed");
            emit SwapApproved(balance);

            address[] memory path = new address[](2);
            path[0] = address(jerryToken);
            path[1] = WETH;

            // Get current exchange rate for the token to ETH swap
            uint[] memory amountsOut = uniswapRouter.getAmountsOut(balance, path);
            uint256 currentRate = amountsOut[1];

            // Apply 5% slippage
            uint256 slippageRate = currentRate / 100 * 5;
            uint256 amountOutMin = currentRate - slippageRate;

            try uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
                balance,
                amountOutMin,
                path,
                address(this),
                block.timestamp
            ) {
                // Swap succeeded
            } catch Error(string memory reason) {
                emit SwapFailed(reason);
                return;  // Swap failed, exit function early
            }

            uint256 ethBalance = address(this).balance;
            require(ethBalance >= 10000000000000000, "Not enough ETH in the contract"); // At least 0.00001 ETH

            // Transfer ETH to developer wallet
            require(developerWallet.send(ethBalance), "Transfer failed");
            emit EtherTransferred(ethBalance);
        }
    }
}
